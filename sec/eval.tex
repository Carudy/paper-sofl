\subsection{Communications}
As illustrated in Section III, our framework only adopts simple algorithms to enhance security. Therefore, the execution overhead can be ignored compared to the communication overhead. Notice that any communication in our framework goes through the server. E.g., if $P_i$ wants to send encrypted message $c$ to $L_j$, $c$ will be sent to server $S$ first. Afterwards $S$ will forward $c$ to $L_j$. In general, our P2P communications are emulated with client/server communications. This method accelerates communication greatly because it costs much for two strangers to exchange messages directly. E.g., if two parties want to communicate directly, both of them need to store the addresses, confirm the ``accept'' signal after each message-exchange, et al. However, with a powerful server helping to forward, these things are no longer concerns for parties.

In each round, there are $n$ common parties and $N_l$ leaders. W.l.o.g., we suppose there is no common party that is also a leader at the same time. Common parties, leaders together with the server $S$ are all parties requiring communication. Generally, $N_l$ is a very small number such as 3, therefore we can treat it as a constant number. Our framework can be categorized into \textbf{set-up} and \textbf{epoch-learning} two phases. We analyze these two phases respectively:

\begin{itemize}
    \item \textbf{Set-up:} All $N-N_l$ parties need to construct secure channels with all $N_l$ leaders. Suppose it needs $D$ communications in each DH protocol, then the amount of communications of the set-up phase is $D * (N-N_l) * N_l$. The time complexity is $O(N)$ based on the fact that $D$ and $N_l$ are small constant numbers.
    
    In the re-organization process, $S$ chooses a new leader that needs to conduct DH protocols with all $N-N_l$ parties, which is $D * (N-N_l)$ communications. Therefore, a re-organization process also costs $O(N)$ communications.
    
    \item \textbf{Epoch-learning:} In each epoch, $S$ sends the current $W_{global}$ to $n$ parties, which cost $n$ communications. Then every common party sends $W_{ij}$ to $N_l$ leaders respectively, which cost $n * N_l$ communications. Finally leaders send $Aj$s to $S$, which cost $N_l$ communications. Thus the total cost of one epoch is $n + n * N_l + N_l$, which is $O(n)$.
\end{itemize}

In the time complexity aspect, our framework does not result in higher overhead expect for an $O(N)$ preprocessing compared to the original FedAvg algorithm. In the vertical aspect, our framework does not require more message-exchanges for any party-leader pair. 

\subsection{Security Evaluation}
The evaluation is based on the fact that our adversaries are all honest-but-curious. Since our framework is based on MPC researches~\cite{Shamir,Du2001SecureMC,Three-Party}, the security against message-leakage can be guaranteed. The riskiest threat is the collusion attack. Colluding with a common party has no contribution to an attack because it lets out nothing but the information about this common party, which belongs to the attacker side. Therefore, we only discuss situations that collusion among leaders. 

Apparently, the attacker must collude with all leaders in order to reconstruct one party's parameter. Since the leaders are assigned by the server randomly, it is hardly possible for all attackers to be elected as leaders with the server being honest. However, it is necessary to discuss the situation where the server cheats to select leaders as its wish, though it does not deviate from the learning protocols. In such situations, the leaders are always selected by the unreliable server. To address this problem, we introduced leader-tenure in Section III, which forces the system to change leaders regularly. Since it needs all leaders' betrayal to attack successfully, the system only needs to change one leader regularly. Changing one leader is equivalent to a re-organization process, which cost $O(N)$ time. Therefore, our framework has high security against collusive honest-but-curious attackers.
